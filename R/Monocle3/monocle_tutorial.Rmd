---
title: "monocle3 documentation"
output:
  html_document:
    toc: yes
    df_print: paged
  html_notebook:
    toc: yes
    css: "C:/Users/13081/OneDrive - webmail.hzau.edu.cn/Github/learn/R/notebook.css"
    number_sections: yes
---


# Installing Monocle 3
## Required software
To install Bioconductor, open R and run:
```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install()
```

Next, install a few Bioconductor dependencies that aren't automatically installed:
```{r}
BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
                       'limma', 'lme4', 'S4Vectors', 'SingleCellExperiment',
                       'SummarizedExperiment', 'batchelor', 'Matrix.utils',
                       'HDF5Array', 'terra', 'ggrastr'))
```

Now, install monocle3 through the cole-trapnell-lab GitHub, execute:
```{r}
install.packages("devtools")
devtools::install_github('cole-trapnell-lab/monocle3')
```

## Testing the installation
To ensure that Monocle 3 was installed correctly, start a new R session and run:
```{r}
library(monocle3)
```


# Clustering and classifying your cells
单细胞实验通常在包含多种细胞类型的组织上进行。Monocle 3 提供了一组简单的函数，您可以使用它们根据基因表达谱将细胞分组到 clusters 中。细胞通常形成对应于一种细胞类型或一组高度相关的细胞类型的 clusters。Monocle 3 使用的技术在单细胞 RNA-seq 分析中被广泛接受，并且类似于 [Seurat](https://satijalab.org/seurat/)、[scanpy](https://scanpy.readthedocs.io/en/stable/) 和其他工具使用的方法。

在本节中，您将学习如何使用 Monocle 3 对细胞进行聚类。我们将展示用于聚类的主要函数，使用的数据是来自 [Cao & Packer et al](https://science.sciencemag.org/content/357/6352/661) 的秀丽隐杆线虫数据。这项研究描述了如何在称为“sci-RNA-seq”的方案中使用组合索引进行单细胞 RNA-seq。Cao & Packer et al. 使用 sci-RNA-seq 对整个动物进行了第一次单细胞 RNA-seq 分析，因此数据中代表了许多细胞类型。您可以在 UW Genome Sciences [RNA Atlas of the Worm](https://atlas.gs.washington.edu/worm-rna/) 网站上了解有关数据集的更多信息，并查看作者如何执行原始分析。

您可以像这样将数据加载到 Monocle 3 中：
```{r}
library(monocle3)
library(dplyr) # imported for some downstream data manipulation

expression_matrix <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_expression.rds"))
cell_metadata <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_colData.rds"))
gene_annotation <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_rowData.rds"))

cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)
```

## Pre-process the data
现在数据都加载好了，我们需要对其进行预处理。这一步是您告诉 Monocle 3 您希望如何 normalize 数据、是否使用 [Principal Components Analysis](https://en.wikipedia.org/wiki/Principal_component_analysis)（RNA-seq 的标准）或 [ Latent Semantic Indexing ](https://en.wikipedia.org/wiki/Latent_semantic_analysis)（在 ATAC-seq 中常见）以及如何消除任何 batch effects 的地方。在本演示中，我们将只使用标准 PCA 方法。使用 PCA 时，您应该指定希望 Monocle 计算的主成分数。

```{r}
cds <- preprocess_cds(cds, num_dim = 100)
```

最好检查一下您是否使用了足够多的 PCs 来捕获数据集中所有细胞的大部分基因表达变化。
您可以使用 `plot_pc_variance_explained()` 查看每个 PC 的可解释变异分数：

```{r}
plot_pc_variance_explained(cds)
```

我们可以看到，使用超过 100 个 PC 只会捕获少量的额外变异，并且每增加一个 PC 都会使 Monocle 中的下游步骤变慢。

## Reduce dimensionality and visualize the cells
现在我们准备好可视化细胞。为此，您可以使用在 scRNAseq 中非常流行的 t-SNE 或越来越常见的 UMAP。Monocle 3 默认使用 UMAP，因为我们认为它更快，更适合 RNA-seq 中的聚类和轨迹分析。要将数据降维到 X、Y 平面以便我们可以轻松绘制它，请调用 `reduce_dimension()`：

```{r}
cds <- reduce_dimension(cds)
```

要绘制数据，请使用 Monocle 的主要绘图函数 `plot_cells()`：

```{r}
plot_cells(cds)
```

上图中的每个点代表 `cell_data_set` 对象 `cds` 中的不同细胞。如您所见，细胞形成许多 groups，一些有数千个细胞，一些只有几个。Cao & Packer 通过查看每个细胞表达的基因，根据类型手动注释每个细胞。我们可以使用 `plot_cells()` 的 `color_cells_by` 参数，根据作者的原始注释为 UMAP 图中的细胞着色。

```{r}
plot_cells(cds, color_cells_by="cao_cell_type")
```

您可以看到许多细胞类型在 UMAP 图中彼此非常靠近。

除了稍后描述的少数情况外，`color_cells_by` 可以是 `colData(cds)` 中任意列的名称。请注意，当 `color_cells_by` 是分类变量时，标签会添加到图中，每个标签大致位于所有具有该标签的细胞的中间。

您还可以根据细胞表达的一个基因或一组基因的数量来为细胞着色：

```{r}
plot_cells(cds, genes=c("cpna-2", "egl-21", "ram-2", "inos-1"))
```
--------------------------------------------------------------------------------

**Faster clustering with UMAP**
如果您有一个相对较大的数据集（具有 >10,000 个或更多的细胞），您可能希望利用可以加速 UMAP 的选项。将 `umap.fast_sgd=TRUE` 传递给 `reduce_dimension()` 将在 UMAP 内部使用快速随机梯度下降法。如果您的计算机有多个内核，您可以使用 `cores` 参数使 UMAP 成为多线程的。但是，使用这些选项中的任何一个调用 `reduce_dimension()` 都会使其在每次运行时产生略有不同的输出。如果您可以接受，您会发现 `reduction_dimension()` 的运行时间显着减少。

--------------------------------------------------------------------------------

如果需要，您还可以使用 t-SNE 可视化您的数据。首先，使用 `reduction_method="tSNE"` 调用 `reduce_dimension`。

```{r}
cds <- reduce_dimension(cds, reduction_method="tSNE")
```

然后，当您调用 `plot_cells()` 时，也将 `reduction_method="tSNE"` 传递给它：

```{r}
plot_cells(cds, reduction_method="tSNE", color_cells_by="cao_cell_type")
```

您实际上可以在同一个 `cds` 对象上使用 UMAP 和 t-SNE 一个不会覆盖另一个的结果。但是您必须在 `plot_cells` 等下游函数中指定您想要的那个。

## Check for and remove batch effects
在进行基因表达分析时，重要的是检查 batch effects，这是在不同实验批次中测量的细胞转录组的系统差异。这些本质上可能是技术性的，例如在单细胞 RNA-seq protocol 中引入的那些，也可能是生物性的，例如可能来自不同窝小鼠的那些。如何识别批次效应并对其进行解释，以免它们混淆您的分析可能是一个复杂的问题，但 Monocle 提供了处理它们的工具。

执行降维时，应始终检查批批次效应。您应该向 `colData` 添加一列，对每个细胞来自哪个批次进行编码。然后您可以简单地按批次为细胞着色。`Cao & Packer et al` 等人在他们的数据中包含一个“plate”注释，指定每个细胞来自哪个 sci-RNA-seq plate。按 plate 对 UMAP 着色显示：

```{r}
plot_cells(cds, color_cells_by="plate", label_cell_groups=FALSE)
```

该数据中的显着批次效应并不明显。如果数据包含因 plate 而产生的更大变化，我们希望看到实际上仅来自一个 plate 的细胞组。尽管如此，我们可以尝试通过运行 `align_cds()` 函数来消除批处理效应：
```{r}
cds <- align_cds(cds, num_dim = 100, alignment_group = "plate")
cds <- reduce_dimension(cds)
```

```{r}
plot_cells(cds, color_cells_by="plate", label_cell_groups=FALSE)
```

当使用 `alignment_group` 参数运行时，`align_cds()` 会尝试使用 [mutual nearest neighbor alignment](https://doi.org/10.1038/nbt.4091) 来消除批次效应，这是 John Marioni 实验室介绍的一种技术。Monocle 3 通过调用 Aaron Lun 的 [batchelor](https://bioconductor.org/packages/release/bioc/html/batchelor.html) 包 来做到这一点。如果您使用 `align_cds()`，请务必调用 `get_citations()` 以了解您应该如何引用 Monocle 所依赖的软件。

## Group cells into clusters
将细胞分组到 clusters 中是识别数据中细胞类型的重要步骤。Monocle 使用一种称为 [community detection](https://doi.org/10.1038/s41598-019-41695-z) 的技术对细胞进行分组。这种方法由 Levine 等人介绍，作为 phenoGraph 算法的一部分。您可以使用 `cluster_cells()` 函数对细胞进行聚类，如下所示：
```{r}
cds <- cluster_cells(cds, resolution=1e-5)
```

```{r}
plot_cells(cds)
```

请注意，现在当我们调用不带参数的 `plot_cells()` 时，它会根据默认值按 cluster 为细胞着色。

`cluster_cells()` 还将细胞划分为更大、分离更充分的组，称为 partitions，使用 Alex Wolf 等人的统计测试，作为其 PAGA 算法的一部分引入。您可以像这样可视化这些分区：
```{r}
plot_cells(cds, color_cells_by="partition", group_cells_by="partition")
```

运行 `cluster_cells()` 后，`plot_cells()` 函数将根据您要为细胞着色的方式分别标记每个细胞 cluster。例如，下面的调用根据细胞类型注释为细胞着色，并且每个 cluster 根据其中最常见的注释进行标记：

```{r}
plot_cells(cds, color_cells_by="cao_cell_type")
```

您可以通过传递 `group_cells_by="partition"` 来选择标记整个分区而不是 clusters。您还可以通过将 `labels_per_group=2` 传递给 `plot_cells()` 来绘制每个 cluster 的前 2 个标签。最后，您可以禁用此标记策略，使 `plot_cells()` 的行为与调用 `cluster_cells()` 之前一样，如下所示：

```{r}
plot_cells(cds, color_cells_by="cao_cell_type", label_groups_by_cluster=FALSE)
```

## Find marker genes expressed by each cluster

一旦细胞聚集在一起，我们就可以询问是什么基因使它们彼此不同。为此，首先调用 `top_markers()` 函数：

```{r}
marker_test_res <- top_markers(cds, group_cells_by="partition", 
                               reference_cells=1000, cores=8)
```

数据框 `marker_test_res` 包含许多指标，用于衡量每个基因在每个分区中的具体表达方式。
我们可以根据 cluster, partition 或 colData(cds) 中的任何分类变量对细胞进行分组。
您可以根据一个或多个特异性指标对表格进行排名，并为每个 cluster 取 top gene。例如，`pseudo_R2` 就是这样一种措施。我们可以像这样根据 `pseudo_R2` 对 markers 进行排序：

```{r}
top_specific_markers <- marker_test_res %>%
                            filter(fraction_expressing >= 0.10) %>%
                            group_by(cell_group) %>%
                            top_n(1, pseudo_R2)

top_specific_marker_ids <- unique(top_specific_markers %>% pull(gene_id))
```

现在，我们可以使用 `plot_genes_by_group` 函数绘制每个组中表达每个 marker 的细胞的表达和分数：

```{r}
plot_genes_by_group(cds,
                    top_specific_marker_ids,
                    group_cells_by="partition",
                    ordering_type="maximal_on_diag",
                    max.size=3)
```

查看多个标记通常会提供信息，只需将第一个参数更改为 `top_n()` 即可：

```{r}
top_specific_markers <- marker_test_res %>%
                            filter(fraction_expressing >= 0.10) %>%
                            group_by(cell_group) %>%
                            top_n(3, pseudo_R2)

top_specific_marker_ids <- unique(top_specific_markers %>% pull(gene_id))

plot_genes_by_group(cds,
                    top_specific_marker_ids,
                    group_cells_by="partition",
                    ordering_type="cluster_row_col",
                    max.size=3)
```

有许多方法可以比较和对比细胞 clusters（and other groupings）。稍后我们将在 [differential expression analysis](https://cole-trapnell-lab.github.io/monocle3/docs/differential) 部分详细探讨它们。

## Annotate your cells according to type

识别数据集中每个细胞的类型对于许多下游分析至关重要。有几种方法可以做到这一点。一种常用的方法是首先将细胞聚类，然后根据其基因表达谱为每个 cluster 分配一种细胞类型。我们已经看到了如何使用 `top_markers()`。回顾与标记基因相关的文献通常会给出表达它的 cluster 的身份的强烈指示。在 Cao & Packer > et al 中，作者查阅了文献和基因表达数据库以寻找限制在每个 cluster 中的标记，以便分配包含在 `colData(cds)$cao_cell_type` 中的身份。

要根据聚类分配细胞类型，我们首先在 `colData(cds)` 中创建一个新列，并使用 `partitions(cds)` 的值对其进行初始化（也可以使用 `clusters(cds)`，具体取决于您的数据集）：

```{r}
colData(cds)$assigned_cell_type <- as.character(partitions(cds))
```

现在，我们可以使用 `dplyr` 包 的 `recode()` 函数将每个 cluster 重新映射到不同的细胞类型：

```{r}
colData(cds)$assigned_cell_type <- dplyr::recode(colData(cds)$assigned_cell_type,
                                                 "1"="Body wall muscle",
                                                 "2"="Germline",
                                                 "3"="Motor neurons",
                                                 "4"="Seam cells",
                                                 "5"="Sex myoblasts",
                                                 "6"="Socket cells",
                                                 "7"="Marginal_cell",
                                                 "8"="Coelomocyte",
                                                 "9"="Am/PH sheath cells",
                                                 "10"="Ciliated neurons",
                                                 "11"="Intestinal/rectal muscle",
                                                 "12"="Excretory gland",
                                                 "13"="Chemosensory neurons",
                                                 "14"="Interneurons",
                                                 "15"="Unclassified eurons",
                                                 "16"="Ciliated neurons",
                                                 "17"="Pharyngeal gland cells",
                                                 "18"="Unclassified neurons",
                                                 "19"="Chemosensory neurons",
                                                 "20"="Ciliated neurons",
                                                 "21"="Ciliated neurons",
                                                 "22"="Inner labial neuron",
                                                 "23"="Ciliated neurons",
                                                 "24"="Ciliated neurons",
                                                 "25"="Ciliated neurons",
                                                 "26"="Hypodermal cells",
                                                 "27"="Mesodermal cells",
                                                 "28"="Motor neurons",
                                                 "29"="Pharyngeal gland cells",
                                                 "30"="Ciliated neurons",
                                                 "31"="Excretory cells",
                                                 "32"="Amphid neuron",
                                                 "33"="Pharyngeal muscle")
```

让我们看看新注释的样子：

```{r}
plot_cells(cds, group_cells_by="partition", color_cells_by="assigned_cell_type")
```

Partition 7 有一些子结构，仅从 `top_markers()` 的输出来看它对应于什么细胞类型或类型并不明显。所以我们可以用 `choose_cells()` 函数隔离出来做进一步分析：

```{r}
cds_subset <- choose_cells(cds)
```

现在我们有一个较小的 `cell_data_set` 对象，它只包含我们想要钻取的分区中的细胞。我们可以使用 `graph_test()` 来识别在该分区的不同细胞子集中差异表达的基因：

```{r}
pr_graph_test_res <- graph_test(cds_subset, neighbor_graph="knn", cores=8)
pr_deg_ids <- row.names(subset(pr_graph_test_res, morans_I > 0.01 & q_value < 0.05))
```

我们将在后面的 [differential expression analysis](https://cole-trapnell-lab.github.io/monocle3/docs/differential/#gene-modules) 部分详细了解 `graph_test()`。我们可以获取在这组细胞中发生变化的所有基因，并将具有相似表达模式的基因分组到模块中：

```{r}
gene_module_df <- find_gene_modules(cds_subset[pr_deg_ids,], resolution=1e-3)
```

绘制这些模块的聚合表达值可以揭示哪些细胞表达哪些模式。

```{r}
plot_cells(cds_subset, genes=gene_module_df, 
           show_trajectory_graph=FALSE, 
           label_cell_groups=FALSE)
```

您可以探索每个模块中的基因或对它们进行 [gene ontology enrichment analysis](http://geneontology.org/)，以收集有关存在哪些细胞类型的见解。假设在这样做之后我们对分区中的细胞类型有了很好的了解。让我们以更精细的分辨率重新聚类细胞，然后查看它们如何与分区中的聚类重叠：

```{r}
cds_subset <- cluster_cells(cds_subset, resolution=1e-2)
plot_cells(cds_subset, color_cells_by="cluster")
```

根据模式的排列方式，我们将进行以下分配：

```{r}
colData(cds_subset)$assigned_cell_type <- as.character(clusters(cds_subset)[colnames(cds_subset)])
colData(cds_subset)$assigned_cell_type <- dplyr::recode(colData(cds_subset)$assigned_cell_type,
                                                        "1"="Sex myoblasts",
                                                        "2"="Somatic gonad precursors",
                                                        "3"="Vulval precursors",
                                                        "4"="Sex myoblasts",
                                                        "5"="Vulval precursors",
                                                        "6"="Somatic gonad precursors",
                                                        "7"="Sex myoblasts",
                                                        "8"="Sex myoblasts",
                                                        "9"="Ciliated neurons",
                                                        "10"="Vulval precursors",
                                                        "11"="Somatic gonad precursor",
                                                        "12"="Distal tip cells",
                                                        "13"="Somatic gonad precursor",
                                                        "14"="Sex myoblasts",
                                                        "15"="Vulval precursors")

plot_cells(cds_subset, group_cells_by="cluster", color_cells_by="assigned_cell_type")
```

现在我们可以将注释从 `cds_subset` 对象传输回完整数据集。我们也会在这个阶段过滤掉低质量的细胞。

```{r}
colData(cds)[colnames(cds_subset),]$assigned_cell_type <- colData(cds_subset)$assigned_cell_type
cds <- cds[,colData(cds)$assigned_cell_type != "Failed QC" | is.na(colData(cds)$assigned_cell_type )]
plot_cells(cds, group_cells_by="partition", 
           color_cells_by="assigned_cell_type", 
           labels_per_group=5)
```

## Automated annotation with Garnett

上述按类型手动注释细胞的过程可能很费力，如果底层 cluster 发生变化，则必须重新完成。我们最近开发了 [Garnett](https://cole-trapnell-lab.github.io/garnett/)，一种用于自动注释细胞的软件工具包。Garnett 根据标记基因对细胞进行分类。如果您经历过手动注释细胞的麻烦，Monocle 可以生成一个可与 Garnett 一起使用的标记基因文件。这将帮助您在将来注释其他数据集，或者如果您在将来改进分析并更新聚类，则可以重新注释这个数据集。

要生成 Garnett 文件，首先要找到每个带注释的细胞类型表达的顶部标记：

```{r}
assigned_type_marker_test_res <- top_markers(cds,
                                             group_cells_by="assigned_cell_type",
                                             reference_cells=1000,
                                             cores=8)
```

接下来，根据您想要的严格程度过滤这些标记：

```{r}
# Require that markers have at least JS specificty score > 0.5 and
# be significant in the logistic test for identifying their cell type:
garnett_markers <- assigned_type_marker_test_res %>%
                        filter(marker_test_q_value < 0.01 & specificity >= 0.5) %>%
                        group_by(cell_group) %>%
                        top_n(5, marker_score)
# Exclude genes that are good markers for more than one cell type:
garnett_markers <- garnett_markers %>% 
                        group_by(gene_short_name) %>%
                        filter(n() == 1)
```

然后调用 `generate_garnett_marker_file`：

```{r}
generate_garnett_marker_file(garnett_markers, file="./marker_file.txt")
```

`generate_garnett_marker_file` 将生成如下文本文件：

```{}
> Cell type Ciliated sensory neurons
expressed: che-3, scd-2, C33A12.4, R102.2, F27C1.11

> Cell type Non-seam hypodermis
expressed: col-14, col-180, F11E6.3, grsp-1, C06A8.3

> Cell type Seam cells
expressed: col-65, col-77, col-107, ram-2, Y47D7A.13

> Cell type Vulval precursors
expressed: col-68, col-145, lin-31, osm-11, Y62E10A.19

> Cell type Body wall muscle
expressed: csq-1, hum-9, cpna-2, tag-278, F41C3.5

> Cell type Coelomocytes
expressed: cup-4, inos-1, Y73F4A.1, ZC116.3, aman-1

> Cell type flp-1 interneurons
expressed: daf-10, flp-1, nlp-10, zig-2, H05L03.3

> Cell type Sex myoblasts
expressed: egl-15, C04E12.2

> Cell type Intestinal/rectal muscle
expressed: egl-20, lbp-2, bgal-1, ttr-10, T23B12.8

> Cell type Am/PH sheath cells
expressed: far-8, F35B12.9, ZK822.4, F20A1.1, T02B11.3

> Cell type Oxygen sensory neurons
expressed: flp-17, gcy-9, gcy-33, ist-1, Y57G11B.97

> Cell type Pharyngeal neurons
expressed: flr-2, nlp-6, F14B6.2, degt-1, flp-28

> Cell type Unclassified neurons
expressed: gar-2, madd-4, twk-49

> Cell type Germline
expressed: gld-1, pgl-1, ppw-2, prg-2, cbd-1

> Cell type Somatic gonad precursors
expressed: inx-9, mnm-2, C36B7.4

> Cell type Touch receptor neurons
expressed: mec-1, mec-7, mec-12, mec-17, mec-18

> Cell type Pharyngeal epithelia
expressed: pgp-14, pqn-74, fipr-2, R03C1.1, Y73F4A.2

> Cell type Pharyngeal muscle
expressed: pqn-29, F31D4.5, R13H4.8, T01B7.8, T20B6.3

> Cell type Pharyngeal gland
expressed: F15A4.6, dod-6, C49G7.3, M04G7.1, phat-4

> Cell type Canal associated neurons
expressed: acbp-6, Y66D12A.14, ZC412.4, C32E8.6, C41A3.1
```

`generate_garnett_marker_file()` 生成的标记文件只是使用 `Garnett` 对细胞进行分类的起点。您可能想要编辑此文件以添加或删除基于文献或其他信息的标记。您还应该考虑定义细胞的子类型，这可以大大增加 `Garnett` 的实用性和准确性。例如，L2 数据包含许多不同类型的神经元。在上面的文件中制作一个“Neuron”细胞类型，然后使用关键字 subtype 来组织神经元的各种亚型，这将使 `Garnett` 更能够识别它们并将它们与非神经元细胞类型区分开来。当您的两种或多种细胞类型在 `plot_genes_by_group()` 中共享它们的大部 top markers 时，请考虑定义一个更广泛的细胞类型定义，它们都是其子类型。您可能还想通过对上面的 `cds` 对象进行子集化并在它们上运行 `top_markers()` 来为神经元的各种子类型定义标记。有关如何丰富标记文件的更多信息，请参阅 [Garnett documentation](https://cole-trapnell-lab.github.io/garnett/docs_m3/)。

当您准备好运行 Garnett 时，加载包：

--------------------------------------------------------------------------------

**Garnett for Monocle 3**

Garnett 最初是为与 Monocle 2 一起工作而编写的。我们已经创建了 Garnett 的一个分支，它与 Monocle 3 一起工作，最终将取代主分支。同时，您必须安装并加载 Garnett 的 Monocle 3 分支！

--------------------------------------------------------------------------------

```{r}
## Install the monocle3 branch of garnett
BiocManager::install(c("org.Mm.eg.db", "org.Hs.eg.db"))
devtools::install_github("cole-trapnell-lab/garnett", ref="monocle3")
```

```{r}
library(garnett)
# install gene database for worm
BiocManager::install("org.Ce.eg.db")
```

现在根据您的标记文件训练 Garnett 分类器，如下所示：

```{r}
colData(cds)$garnett_cluster <- clusters(cds)
worm_classifier <- train_cell_classifier(cds = cds,
                                         marker_file = "./marker_file.txt", 
                                         db=org.Ce.eg.db::org.Ce.eg.db,
                                         cds_gene_id_type = "ENSEMBL",
                                         num_unknown = 50,
                                         marker_file_gene_id_type = "SYMBOL",
                                         cores=8)
```

现在我们已经训练了一个分类器 `worm_classifier`，我们可以使用它根据类型对 L2 单元格进行注释：

```{r}
cds <- classify_cells(cds, worm_classifier,
                      db = org.Ce.eg.db::org.Ce.eg.db,
                      cluster_extend = TRUE,
                      cds_gene_id_type = "ENSEMBL")
```

以下是 Garnett 对单细胞进行注释的方式：

```{r}
plot_cells(cds,
           group_cells_by="partition",
           color_cells_by="cluster_ext_type")
```

Garnett 分类器可以应用于训练它们的数据集以外的数据集。我们强烈建议您分享您的 Garnett 文件并将它们包含在您的论文中，以便其他人可以使用它们。

作为撰写有关 Garnett 的论文的一部分，我们训练了一个 Garnett 模型以根据 L2 数据对秀丽隐杆线虫细胞进行分类。您可以通过先下载然后将其传递给 `classify_cells()` 函数来使用它对细胞进行分类：

```{r}
library(org.Ce.eg.db)
ceWhole <- readRDS(url("https://cole-trapnell-lab.github.io/garnett/classifiers/ceWhole_20191017.RDS"))
cds <- classify_cells(cds, ceWhole,
                      db = org.Ce.eg.db,
                      cluster_extend = TRUE,
                      cds_gene_id_type = "ENSEMBL")
```



# Constructing single-cell trajectories
在发育过程中，为了响应刺激，以及在整个生命过程中，细胞从一种功能“状态”转变为另一种功能“状态”。处于不同状态的细胞表达不同的基因组，产生动态的蛋白质和代谢物库来执行它们的工作。当细胞在状态之间移动时，它们会经历转录重新配置的过程，其中一些基因被沉默，而另一些则被新激活。这些瞬态通常很难表征，因为在更稳定的终点状态之间纯化细胞可能很困难或不可能。scRNAseq 无需纯化即可让您看到这些状态。然而，为此，我们必须确定每个细胞在可能状态范围内的位置。

Monocle 介绍了使用 RNA-Seq 进行单细胞轨迹分析的策略。Monocle 不是通过实验将细胞纯化为离散状态，而是使用一种算法来了解每个细胞作为动态生物过程的一部分必须经历的基因表达变化的顺序。一旦了解了基因表达变化的总体“轨迹”，Monocle 就可以将每个细胞置于轨迹中的适当位置。然后，您可以使用 Monocle 的差异分析工具包来查找在轨迹过程中受调节的基因，这一分析过程在 [Finding genes that change as a function of pseudotime](https://cole-trapnell-lab.github.io/monocle3/docs/differential/#pseudo-dep) 中介绍。如果该过程有多个结果，Monocle 将重建一个“分支”轨迹。这些分支对应于细胞的“决定”，而 Monocle 提供了强大的工具来识别受它们影响并参与制定它们的基因。您可以在 [Analyzing branches in single-cell trajectories](https://cole-trapnell-lab.github.io/monocle3/docs/differential/#branches) 部分查看如何分析分支。

重建轨迹的工作流程与聚类的工作流程非常相似，但它有几个额外的步骤。为了说明工作流程，我们将使用另一个 C. elegans 数据集，这个数据集来自 [Packer & Zhu et al](https://dx.doi.org/10.1101/565549)。他们的研究包括对整个发育胚胎的时间序列分析。我们将检查一小部分数据，其中包括大部分神经元。我们将像处理 L2 数据一样加载它：```{r}
expression_matrix <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/packer_embryo_expression.rds"))
cell_metadata <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/packer_embryo_colData.rds"))
gene_annotation <- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/packer_embryo_rowData.rds"))

cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)
```

## Pre-process the data
预处理的工作原理与聚类分析完全相同。这一次，我们将使用不同的策略进行 batch correction，其中包括 Packer & Zhu et al 在他们原始分析中所做的：
注意：您的数据不会有此处显示的加载批次信息，您将使用自己的批次信息更正批次。
```{r}
cds <- preprocess_cds(cds, num_dim = 50)
cds <- align_cds(cds, alignment_group = "batch", residual_model_formula_str = "~ bg.300.loading + bg.400.loading + bg.500.1.loading + bg.500.2.loading + bg.r17.loading + bg.b01.loading + bg.b02.loading")
```
请注意，除了使用 `align_cds()` 的 `alignment_group` 参数对齐细胞组 (i.e. batches) 之外，我们还使用了 `residual_model_formula_str`。此参数用于减去连续效应。您可以使用它来控制诸如每个细胞中线粒体 reads 的分数之类的事情，它有时用作每个细胞的 QC 指标。在这个实验中（与许多 scRNA-seq 实验一样），一些细胞自发裂解，在加载到单细胞文库准备之前立即将它们的 mRNA 释放到细胞悬浮液中。这种“上清液 RNA”在一定程度上污染了每个细胞的转录组谱。幸运的是，估计每批细胞的背景污染水平并减去它是相当简单的，这就是 Packer 等人在最初研究中所做的。每一列 `bg.300.loading`、`bg.400.loading` 都对应于细胞可能被污染的背景信号。将这些列作为项传递到 `residual_model_formula_str` 中会告诉 `align_cds()` 在降维、聚类和轨迹推断之前减去这些信号。请注意，您可以使用 `alignment_group`、`residual_model_formula` 或两者调用 `align_cds()`。

## Reduce dimensionality and visualize the results
接下来，我们对数据进行降维。但是，与 UMAP 和 t-SNE 都适用的聚类不同，我们强烈建议您使用默认方法 UMAP：
```{r}
cds <- reduce_dimension(cds)
plot_cells(cds, label_groups_by_cluster=FALSE,  color_cells_by = "cell.type")
```
如您所见，尽管我们只查看该数据集的一小部分，但 Monocle 重建了具有许多分支的轨迹。
在 UMAP 上叠加手动注释表明这些分支主要由一种细胞类型占据。

与聚类分析一样，您可以使用 `plot_cells()` 来可视化单个基因如何沿轨迹变化。
让我们看一些在纤毛神经元中具有有趣表达模式的基因：
```{r}
ciliated_genes <- c("che-1",
                    "hlh-17",
                    "nhr-6",
                    "dmd-6",
                    "ceh-36",
                    "ham-1")

plot_cells(cds,
           genes=ciliated_genes,
           label_cell_groups=FALSE,
           show_trajectory_graph=FALSE)
```
我们将在稍后的 [Finding genes that change as a function of pseudotime](https://cole-trapnell-lab.github.io/monocle3/docs/differential/#pseudo-dep) 部分中学习如何识别受限于轨迹的每个结果的基因。

## Cluster your cells
虽然细胞可以连续地从一种状态过渡到另一种状态，它们之间没有离散的边界，但 Monocle 并不假设数据集中的所有细胞都来自一个共同的转录“祖先”。在许多实验中，实际上可能存
在多个不同的轨迹。例如，在对感染做出反应的组织中，组织驻留的免疫细胞和基质细胞将
具有非常不同的初始转录组，并且对感染的反应也大不相同，因此它们应该属于同一轨迹的
一部分。

Monocle 能够通过其聚类过程了解何时应将细胞放置在相同的轨迹中，而不是单独的轨迹中。
回想一下，我们运行 `cluster_cells()`，每个细胞不仅分配给一个 cluster，还分配给一个 partition。当你在学习轨迹时，每个 partition 最终都会变成一个单独的轨迹。 我们像以前一样运行 `cluster_cells()`。
```{r}
cds <- cluster_cells(cds)
plot_cells(cds, color_cells_by = "partition")
```

## Learn the trajectory graph
接下来，我们将使用 `learn_graph()` 函数在每个分区内拟合一个主图：
```{r}
cds <- learn_graph(cds)
```

```{r}
plot_cells(cds,
           color_cells_by = "cell.type",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)
```
该图将用于许多下游步骤，例如分支分析和差异表达。

## Order the cells in pseudotime
一旦我们学会了一个图表，我们就可以根据细胞在发育程序中的过程对它们进行排序。
Monocle 在 pseudotime 中测量这一过程。下面定义了什么是 pseudotime。

--------------------------------------------------------------------------------

**What is pseudotime?**  
Pseudotime 是衡量单个细胞通过细胞分化等过程取得多少进展的指标。

在许多生物过程中，细胞不会以完美的同步方式发展。在细胞分化等过程的单细胞表达研究
中，捕获的细胞可能在过程中广泛分布。也就是说，在同一时间捕获的一组细胞中，一些细
胞可能还很远，而另一些细胞甚至可能还没有开始这个过程。当您想了解细胞从一种状态转
换到另一种状态时发生的一系列调节变化时，这种异步会产生重大问题。跟踪同时捕获的跨
细胞的表达会产生对基因动力学的非常压缩的感觉，并且该基因表达的明显可变性将非常高。

通过根据学习轨迹上的进度对每个细胞进行排序，Monocle 缓解了由于异步而出现的问题。
Monocle 不是将表达的变化作为时间的函数来跟踪，而是将变化作为沿着轨迹的进展的函数
来跟踪，我们称之为“pseudotime”。pseudotime是进度的抽象单位：它只是一个细胞与轨迹
起点之间的距离，沿最短路径测量。轨迹的总长度是根据细胞从起始状态移动到结束状态时
所经历的转录变化总量来定义的。  

-------------------------------------------------------------------------------- 

为了将细胞按顺序排列，我们需要告诉 Monocle 生物过程的“起点”在哪里。
我们通过选择我们标记为轨迹“root”的图区域来做到这一点。在时间序列实验中，这通常
可以通过在 UMAP 空间中找到被早期时间点的细胞占据的点来完成：
```{r}
plot_cells(cds,
           color_cells_by = "embryo.time.bin",
           label_cell_groups=FALSE,
           label_leaves=TRUE,
           label_branch_points=TRUE,
           graph_label_size=1.5)
```

黑线表示图的结构。请注意，该图不是完全连接的：不同 partition 中的细胞位于图的不同
组件中。带有数字的圆圈表示图中的特殊点。每片叶子，用浅灰色圆圈表示，对应于轨迹的
不同结果（即细胞命运）。黑色圆圈表示分支节点，细胞可以在其中移动到几个结果之一。
您可以使用 `plot_cells` 的 `label_leaves` 和 `label_branch_points` 参数控制这些是否显示在图中。请注意，圆圈内的数字仅供参考。

现在我们已经了解了早期细胞的位置，我们可以调用 `order_cells()`， 它将计算每个细胞在拟时序中的位置。为此，`order_cells()` 需要您指定轨迹图的根节点。如果您不提供它们作为参
数，它将启动一个图形用户界面来选择一个或多个根节点。
```{r}
cds <- order_cells(cds)
```

在上面的示例中，我们只选择了一个位置，但您可以选择任意多个。绘制细胞并用拟时序着
色显示它们是如何排序的：
```{r}
plot_cells(cds,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)
```

请注意，某些细胞是灰色的。这意味着它们有 infinite pseudotime， 因为它们无法从被选择的根节点到达。通常，分区上缺少根节点的任何细胞都将被分配一个 infinite pseudotime。通常，您应该为每个 partition 至少选择一个根节点。

通常需要以编程方式指定轨迹的根节点，而不是手动选取它。
下面的函数首先根据它们最接近的轨迹图节点对细胞进行分组。然后，它计算每个节点的细胞有多少来自最早的时间点。然后它选择被早期细胞占用最多的节点并将其作为根节点返回。
```{r}
# a helper function to identify the root principal points:
get_earliest_principal_node <- function(cds, time_bin="130-170"){
  cell_ids <- which(colData(cds)[, "embryo.time.bin"] == time_bin)
  
  closest_vertex <-
  cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes <-
  igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
  (which.max(table(closest_vertex[cell_ids,]))))]
  
  root_pr_nodes
}
cds <- order_cells(cds, root_pr_nodes=get_earliest_principal_node(cds))
```

通过 `root_pr_node` 参数将程序选择的根节点传递给 `order_cells()` ：
```{r}
plot_cells(cds,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)
```
请注意，我们可以通过首先使用 `partitions()` 函数按 partition 对细胞进行分组，在每个 partition 的基础上轻松地执行此操作。这将导致所有细胞都被分配一个有限的 pseudotime。


## Subset cells by branch
根据轨迹中的分支对细胞进行 subset 通常很有用。函数 `choose_graph_segments`  允许您以交互方式执行此操作。
```{r}
cds_sub <- choose_graph_segments(cds)
```


## Working with 3D trajectories
```{r}
cds_3d <- reduce_dimension(cds, max_components = 3)
cds_3d <- cluster_cells(cds_3d)
cds_3d <- learn_graph(cds_3d)
cds_3d <- order_cells(cds_3d, root_pr_nodes=get_earliest_principal_node(cds))

cds_3d_plot_obj <- plot_cells_3d(cds_3d, color_cells_by="partition")
```






