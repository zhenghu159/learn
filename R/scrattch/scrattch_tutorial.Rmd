---
title: "scrattch.hicat tutorial"
date: '2022-07-09'
author: ZhengHu
output: 
  html_notebook: 
    toc: yes
    css: scrattch.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T)
```

# 1 Data Selection
## 1.1 Loading libraries
首先，我们需要加载 `scattch.hicat` 和 `tasic2016data` 包，以及 `Matrix` 和 `matrixStats`，我们将使用它们进行一些计算：

```{r}
library(tasic2016data)
library(scrattch.hicat)
library(dendextend)
library(dplyr)
library(matrixStats)
library(Matrix)
```

## 1.2 tasic2016data overview
`tasic2016data` 包以 `tasic_2016_anno` 对象的形式提供样本注释，并以 `tasic_2016_counts` 形式提供每个基因 count 数据的矩阵。

```{r}
dim(tasic_2016_anno)
head(tasic_2016_anno)
dim(tasic_2016_counts)
tasic_2016_counts[1:5,1:5]
```

## 1.3 Sample selection
对于这个演示，我们将选择 CGE-derived interneurons 的一小部分进行聚类。 这为我们提供了一组 284 single-cell transcriptomic profiles， 以便后续分析步骤快速运行。

```{r}
select.cells <- tasic_2016_anno %>%
  filter(primary_type_label != "unclassified") %>%
  filter(grepl("Igtp|Ndnf|Vip|Sncg|Smad3", primary_type_label)) %>%
  select(sample_name) %>%
  unlist()

length(select.cells)
```

## 1.4 Reference setup
接下来，我们将设置 cluster annotations 以用作参考 (**ref.cl.df**)。
这些注释来自 Tasic, et al., (2016) 中的分析。

```{r}
ref_anno <- tasic_2016_anno %>%
  filter(sample_name %in% select.cells)

# Make a data.frame of unique cluster id, type, color, and broad type
ref.cl.df <- ref_anno %>%
  select(primary_type_id, 
         primary_type_label, 
         primary_type_color, 
         broad_type) %>%
  unique()

#standardize cluster annoation with cluster_id, cluster_label and cluster_color. These are the required fields to visualize clusters properly.
colnames(ref.cl.df)[1:3] <- c("cluster_id", "cluster_label", "cluster_color")

# Sort by cluster_id
ref.cl.df <- arrange(ref.cl.df, cluster_id)
row.names(ref.cl.df) <- ref.cl.df$cluster_id

# Set up the ref.cl factor object
ref.cl <- setNames(factor(ref_anno$primary_type_id), ref_anno$sample_name)
```

```{r}
head(ref.cl.df)
head(ref.cl)
```

## 1.5 Data normalization
为了归一化数据，我们将执行两个步骤：
首先，使用 `cpm()` 函数将 counts 转换为 counts per million reads (CPM)。
然后，使用 `log2()` 函数对结果进行对数转换。

```{r}
tasic_2016_cpm <- cpm(tasic_2016_counts[,select.cells])
norm.dat <- log2(tasic_2016_cpm + 1)
```

如果您有一个非常大的矩阵，我们建议您使用 `Matrix` 包将其转换为稀疏矩阵以节省内存。
虽然这里没有必要，但我们将这样做来演示这些矩阵的使用。

```{r}
norm.dat <- Matrix(norm.dat, sparse = TRUE)
```


---------------------------------------------------------------------------------


# 2 Setting Parameters
## 2.1 Parameter Descriptions
这种迭代聚类算法产生的最终聚类数量很大程度上取决于用户指定的所需细胞类型分辨率。
细胞类型分辨率由 pair of clusters 之间的差异表达 (DE) 标准定义。
用户可以提前指定这些标准，以便通过使用 `de_param()` 函数在 hicat 函数中重新使用。  
<br/>我们使用 `limma` 计算 DE genes 的统计意义，其中两个关键参数指定如下：  
**padj.th**: adjusted p value threshold for DE genes.  
**lfc.th**: log2 fold change threshold for DE genes.  

<br/>我们还要求 DE genes 具有相对 binary (on/off) 的表达模式，由以下参数指定：  
**low.th**: 用于确定是否在给定细胞中检测到基因的最小值。
此阈值适用于 log2-transformed, normalized data。默认值为 1。
如有必要，用户可以为不同的基因指定不同的阈值。
对于每一对 clusters (one as foreground, and the other as background)，我们定义了 q1 和 q2 作为分别在 foreground 和 background cluster 中表达大于 low.th  的细胞的比例。
**q1.th**：对于上调基因，q1 应该大于 foreground set 中的 q1.th。  
**q2.th**：对于上调基因，q2 应该小于background set 中的 q2.th。  
**q.diff.th**：差异，定义为 abs(q1 - q2)/max(q1, q2) 应大于 q.diff.th。  
**默认值**：q1.th = 0.5, q2.th = NULL, q.diff.th = 0.7.






